
<img src="./static/images/kotlin.png" style="width:50%;"/>

### Qu√© es la Java Virtual Machine

Una virtual machine es una virtualizaci√≥n o simulaci√≥n de un sistema operativo o de los procesos que ocurren dentro de este. En nuestro caso, la Java Virtual Machine pertenece al segundo tipo y se encarga de simular los procesos que ocurren dentro de un sistema operativo. A este tipo de m√°quinas virtuales se les llama Process Virtual Machines.

### ¬øQu√© ventaja nos da?

Nos ayuda a manejar los punteros y las referencias de memoria que en otros tipos de lenguaje como C o C++ hay que manejar manualmente. Para esto se utiliza un proceso llamado garbage collection. Este proceso se encarga de revisar qu√© referencia de memoria no se est√° utilizando para eliminarla y as√≠ reducir la cantidad memoria que puede consumir un programa.

### ¬øC√≥mo funciona la JVM?

La JVM funciona como un punto medio entre el c√≥digo que nosotros escribimos y lo que entiende el sistema operativo del ordenador. Dependiendo del sistema operativo que uses puede variar. La JVM nos ayuda a que nuestro c√≥digo se ejecute en Linux, Windows y MacOS. Nuestro c√≥digo es convertido por la JVM a un lenguaje que puede entender el sistema operativo llamado Java Bytecode.

En palabras m√°s simples, nosotros ingresamos c√≥digo de Kotlin y se transforma en Bytecode. Este proceso puede ocurrir con otros lenguajes como Java, esto hace que nuestro c√≥digo de Kotlin pueda ser utilizado desde Java y el c√≥digo de Java pueda ser utilizado en Kotlin.


<img src="./static/images/kotlin_924.png" style="width:50%;margin-left: auto; margin-right: auto"/>



### Carpetas y ficheros a la izquierda

SI inician con un ** punto ‚Äú.‚Äù **, guardan informaci√≥n de nuestro proyecto.

* ‚Äúgradle‚Äù es un sistema de compilacion de Android
* "build" carpeta que almacena el codigo compilado por gradle
* "src" carpeta m√°s importante donde se encuentra nuestro codigo
* _‚Äòmain.kt‚Äô _ fichero que sirve como punto de entrada para el desarrollo de nuestra app
* "test" carpeta de tests necesarios para la app
* _‚Äòbuild.gradle.kts‚Äô _ fichero que contiene la configuraci√≥n de como funciona el proyecto, versiones, dependencias, etc.
* _‚Äògradle.properties‚Äô _ fichero que permite declarar propiedades del proyecto
* ‚Äôseetings.gradle.kts‚Äô fichero para especificar propiedades del proyecto


### Variables en Kotlin

var = valores que pueden cambiar
val = valores que no pueden cambiar
const val = valores que no deben camiar nunca, se declaran fuera de las funciones

Declarar variables

{var/val/const val} {nombreVariable} : {Tipo de dato (opcional)} = {valor}


```java
const val PI = 3.1415 //constante

fun main(args: Array<String>) {
    println("Hello World!")
    var optionA = 80 //variable mutable
    println( "numero: "+optionA)
    optionA = 50
    println( "numero cambiado: "+  optionA )

    val name = "susana" //variable inmutable
    println("name: "+ name )
    println("pi"+PI)

```

### Modificadores y tipos de datos en Kotlin

¬øQu√© es un dato primitivo
Tipos de datos originales de un lenguaje de programaci√≥n. En Kotlin lo son los enteros, booleanos y cadenas de texto

¬øQu√© es un objeto
Es una combinaci√≥n de variables, funciones y otros objetos.
En Kotlin todo es un objeto, se convierten los datos primitivos a un objeto para obtener algunas ventajas como:

Crear funciones especificas para el objeto que ayuden a no reescribir el c√≥digo

Sobrescribir operadores como la suma o multiplicaci√≥n

-Enteros
-Cadenas de texto
-Booleanos

Comparten en com√∫n que son primitivos ya que vienen directamente con el lenguaje, con ellos se pueden crear objetos.

### Operaciones con los tipos de datos en Kotlin

En Kotlin las operaciones son traducidas a funciones interiormente por el compilador. La operaci√≥n val tercerValor = primerValor + segundoValor es lo mismo que decir tercerValor = primerValor.plus(segundoValor).

En la siguiente tabla te voy a dejar las operaciones que vas a poder realizar con los distintos tipos de datos y si te encuentras con alguno que no permita realizar esa operaci√≥n puedes crearla por tu cuenta. Recuerda que Kotlin te permite extender el lenguaje para aprovechar estas funcionalidades.

Operaciones m√°s utilizadas

|Expresi√≥n |	Funci√≥n 	|Operator Fun|
|----------|------------|--------------|
|a + b 	| c = a + b |	public operator fun plus(other: Int): Int|
|a - b 	|c = a - b 	|public operator fun minus(other: Int): Int|
|a * b 	|c = a * b 	|public operator fun times(other: Int): Int|
|a / b 	|a = a / b 	|public operator fun div(other: Int): Int|
|a % b 	|c = a % b 	|public operator fun rem(other: Int): Int|
|a++ 	  |c = a++ 	  |public operator fun inc(): Int|
|a‚Äì 	  |c = a‚Äì 	  |public operator fun dec(): Int|
|a > b 	|c = a > b 	|public override operator fun compareTo(other: Int): Int|
|a < b 	|c = a < b 	|public override operator fun compareTo(other: Int): Int|
|a >= b  |c = a >= b |public override operator fun compareTo(other: Int)|: Int|
|a <= b |c = a <= b |public override operator fun compareTo(other: Int)|: Int|
|a != b |c = a != b 	|public open operator fun equals(other: Any?): |Boolean|

Dependiendo del tipo de dato que tengas podr√°s utilizar todos o solamente algunas de estas operaciones, por ejemplo si tienes una variable del tipo de dato String no vas a poder dividirla, a menos que t√∫ crees esa funci√≥n. Sin embargo, s√≠ vas a poder sumar dos variables del tipo de dato String para obtener el valor de dicha suma.

Con esto espero que hayas obtenido una idea sobre c√≥mo funcionan las operaciones, queda de parte de ti si prefieres utilizar la versi√≥n larga del operator fun o el operador directamente.

Ten en cuenta que si las operator fun se inventaron para que puedas reducir tu c√≥digo a operaciones con s√≠mbolos ¬øpor algo ser√°, no?


### Paradigmas de la programaci√≥n:

Son formas de escribir c√≥digo.

* Paradigma Imperativo: Se basa en modificar variables de estado que se encuentran dentro del programa y as√≠ hacer que el c√≥digo realice las tareas que quieres.

* Paradigma declarativo: programacion funcional Nos ayuda a entender que es lo que tiene que hacer un programa, como hace las cosas el programa.



### CONDICIONAL IF

Es un mecanismo que nos proporciona el lenguaje para evaluar condiciones que son true o false y as√≠ decidir que bloque de codigo se va a ejecutar.  

Para evaluar las condiciones con la sentencia if debemos aprender el concepto de operador condicional, este operador nos van a servir para evaluar condiciones, los operadores condicional son:  

```
> mayor que.
< menor que.
>= mayor o igual que.
<= menor o igual que
== igualdad.
!= desigualdad.  

```
OPERADORES LOGICOS

Con los operadores logicos podremos comparar mas de una condici√≥n.  

&& operador "y": con este operador todas las condiciones tienen que ser verdaderas para que se cumpla la sentencia if.  

|| operador "o": basta que se cumpla una de las condiciones para que se cumpla la sentencia if.  

! operador "no"

### ESTRUCTURA DE CONTROL WHEN

Esta sentencia sirve en los casos que tengamos que comparar nuestra variable con m√∫ltiples opciones, ya que con la sentencia IF puede resultar poco optimo. 

SINTAXIS WHEN

* Iniciamos con la palabra reservada WHEN.
* Entre parentesis () escribimos la variable o constante que queremos evaluar.
* Posteriormente, vamos abrir y cerrar llaves {}, dentro de estas escribiremos las diferentes condiciones o casos.
* Cada vez que creamos un condici√≥n deberemos escribir un guion y un mayor que (->), luego entre llaves {} colocaremos el bloque de codigo que se va a ejecutar, para ello se escribe println(‚Äúel mensaje que va a salir por consola‚Äù).
* Por ultimo, utilizaremos ELSE para definir un bloque de codigo en caso que ninguna de nuestras opciones coincidan con el valor de nuestra variable.

EJEMPLO CON STRING

<EJEMPLO:

```java
val pais = "Argentina"

when(pais) {
    "Argentina" -> {
        println("El idioma de ${pais} es Espa√±ol");
    } "Alemania" -> {
        println("El idioma de ${pais} es Aleman");
    } "EEUU" -> {
        println("El idioma de ${pais} es Ingles");
    } "Brasil" -> {
        println("El idioma de ${pais} es Portugues");
    } else -> {
        println("No conocemos el idioma");
    }
} > 
```

Si tenemos varios casos que coinciden con el mismo valor, lo podremos unir en una √∫nica condici√≥n colocando una coma(,) al final de cada condici√≥n.   

Al trabajar con when y n√∫meros enteros (Int) podremos usar rangos, para ello debemos:  

* Se utiliza la misma sintaxis.
* En los casos o condiciones utilizaremos la palabra reservada IN.
* Seguido del valor inicial.
* Luego escribir dos puntos (‚Ä¶) y
* Por ultimo, colocamos el valor en donde se quiere que termine nuestro rango.

EJEMPLO CON NUMEROS ENTEROS

```java
val edad = 33;

when(edad) {
    in 0..3 -> {
        println("Tu edad es ${edad} eres un bebe");
    } in 4..11 -> {
        println("Tu edad es ${edad} eres un ni√±o");
    } in 12..18 -> {
        println("Tu edad es ${edad} eres un adolecente");
    } in 19..59 -> {
        println("Tu edad es ${edad} eres un adulto");
    } in 60..99 -> {
        println("Tu edad es ${edad} eres un adulto mayor");
    } else -> {
        println("üò≤");
    }
}> 
```

### Bucles: While y Do While

Con while podemos hacer que se ejecute un bloque de c√≥digo determinado hasta que se cumpla una condici√≥n.

Cuando usamos este tipo de bucles hay que tener cuidado para evitar producir bucles infinitos no deseados, para lo que necesitamos que dentro del bucle se actualice el valor que usemos en la condici√≥n de salida bajo alguna circunstancia.

En el siguiente ejemplo se ejecuta el bucle mientras (while) el d√≠a sea menor que 6 y cuando deja de cumplirse termina.

```java
var dia= 1
println("Empiza la semana")
while(dia < 6) {
    if  (dia == 1) {
        println("$dia dia trabajando")
    } else {
        println("$dia dias trabajando")
    }

    dia++ // Actualizamos la condicion
}
println("A descansar")

/* Resultado:
Empiza la semana
1 dia trabajando
2 dias trabajando
3 dias trabajando
4 dias trabajando
5 dias trabajando
A descansar
*/
```

### Null-Safety en Kotlin


Por defecto, todas las variables en Kotlin son non-nullable. De este modo, si intentamos asignar un valor null a cualquier variable, el compilador lanzar√° un error:

```java
var saludoNullable: String? = "Hola"
saludoNullable = null // Compila
```
Si queremos permitir que una variable pueda ser null, tendremos que definirla a√±adiendo ? a su tipo de datos.

## nullables

cuando declaras las variables de manera normal, estas no pueden ser inicializadas como null pero s agregamos un **? despues del tipo de dato nos permitira agregar un null**

este tipo de datos es para evitar el null pointer exeption 

si necesitamos obtener la longitud de nuestra variable con ? nos marcara un error pero podemos evitarlo usando un unsafe !!

```java
var myVar : String? = null
//unsafe operator
println(myVar!!.length)
```

## Null-Safety

Una variable es nula, cuando no se le ha asignado un valor 

Sir Tony Hoare, creo la referencia null o null pointer en 1965

Se recomienda evitar usar null, pues este nos puede causar errores al correr la app

### Nulable

Un tipo de dato nullable es una variable que puede contener un null, la forma en que se declaran es la siguiente:

```java
var segundoNombre? = "Maribel"
```

### Safe calls

es una herramienta que nos proporciona Kotlin, que nos hayuda a ejecutar cierto codigo cuando la variable no es nula, y lo realizamo de la sigueinte manera:

```java
println(segundoNombre?.length())
```

### Double bang !!

el operador !! le dice al compilador que estas 100% seguro de que en ese punto la variable no es null.

Se recomienda usarlo poco, por que puede ser considerado mala practica y ademas puede que la variable si llegue null 

### Elvis operation

Elvis operation ?: nos regresa un valor por defecto cuando una variable  es null y de esa forma evitamos ciertos errores

```java
fun main() {
    //cone el signo ? indicamos que la variable puede ser null
    var nombre : String? =  null;

    val caracterNumber :Int = nombre?.length ?: 0
    println(caracterNumber)

}
```

Ojo!

* Tu no puedes tener un catch o finally sin un try
* Tu no puedes poner codigo entre el try y el catch, o el catch y el finally.

por ejemplo:

```java
try { callRiskyCode( ) }
x = 7
catch(e: Bad Exception) {}
```

* Un try puede estar seguido de un catch o un finally
* Un try puede tener multiples catch blocks.

Esta explicacion esta en el libro Head First Kotlin en la pagina 244. Un gran libro en ingles que recomiendo mucho!


### 0El Elvis operator ?: 

Es una versi√≥n segura de una expresi√≥n if. Devuelve el valor a su izquierda si no es nulo. De lo contrario, devuelve el valor a su derecha‚Ä¶ por ejemplo:

```java
w?.play ?: -1

```

El Elvis operator primero verifica el valor a su izquierda, en este caso w?.play y si ese valor no es null, el Elvis operator lo retorna. En el caso de que el valor de la izquierda sea null, el Elvis operator retornara el valor de la derecha, en este caso -1

es como decir "si w no es nulo y su propiedad de play no es nula, devuelve el valor de la propiedad de play, de lo contrario, devuelve -1

Pueden encontrar mas informaci√≥n sobre este tema en el libro que les recomende anteriormente Head First Kotlin!

### Listas


* Las listas son inmutables, si queremos agregar, remover o usar funciones mas avanzadas necesitaremos una mutableList.
* Podemos tener valores duplicados en una lista
* Podemos recorrer todos los elementos de una lista
* La principal diferencia entre una lista y un array es que la lista no puede actualizar ninguna de las referencias que almacena


```java
fun main(args: Array<String>) {

    // Lista inmutable
    val listaDeNombre = listOf("Nestor", "Joel", "Camila")
    println(listaDeNombre)

    // Lista mutable
    val listaVacia = mutableListOf<String>()
    println(listaVacia)
    listaVacia.add("Nestor") //.add agregar un valor a la lista
    println(listaVacia)

    val valorUsandoGet = listaVacia.get(0) //.get Obtener el valor de la lista
    println(valorUsandoGet)

    val valorUsandoOperador = listaVacia[0]
    println(valorUsandoOperador)


    val primerValor: String? = listaDeNombre.firstOrNull() // .first Obtener el  primer valor de una lista
    println(primerValor)

    listaVacia.removeAt(0) // removeAt Eliminar elementos de la una lista
    println(listaVacia)

    listaVacia.add("Joel")
    listaVacia.removeIf() {caracteres -> caracteres.length > 3} // removeIf Solo cuando la condicion sea valida
    println(listaVacia)

    val myArray = arrayOf(1,2,3,4,5)
    println("Mi array $myArray")
    println("Array como lista ${myArray.toList()}")
    
    // Para performance utilizar siempre arrays ** de lo contraria utilizar listas
}

```

### Filtrar listas

```java
fun main(args: Array<String>) {
    val numerosDeLoteria = listOf(11, 15, 30, 66, 5)

    //Ordenar ascendentemente con sorted
    val numerosSorted = numerosDeLoteria.sorted()
    println(numerosSorted)

    //Ordenar descendentemente con sortedDescending
    val numerosDescendientes = numerosDeLoteria.sortedDescending()
    println(numerosDescendientes)

    //Ordenar dependiendo de una condici√≥n con sortedBy
    val ordenarPorMultipos = numerosDeLoteria.sortedBy { num -> num < 50 }
    println(ordenarPorMultipos)

    //Ordenar de forma aleatoria
    val numerosAletorios = numerosDeLoteria.shuffled()
    println(numerosAletorios)

    //Ordenar de forma inversa
    val numerosEnReversa = numerosDeLoteria.reversed()
    println(numerosEnReversa)


    //Funciones de programaci√≥n funcional

    //Map - Convertir un elemento de un tipo a otro tipo // siempre devuelve el ultimo valor

    val mensajesDeNumeros = numerosDeLoteria.map { num -> "Tu numero de loter√≠a es $num" }
    println(mensajesDeNumeros)

    //Filtrar elementos dependiendo de condiciones con filter
    val numerosFiltrados = numerosDeLoteria.filter { num -> num > 50 }
    println(numerosFiltrados)
}

```

### Maps

Los mapas asocian claves con valores. Las claves deben ser √∫nicas, pero los valores asociados no. De este modo, cada valor puede ser usado para identificar de manera √∫nica el valor asociado, ya que el mapa asegura que no puedes duplicar claves en la colecci√≥n. Internamente, Kotlin usa la colecci√≥n Java Map para implementar los mapas.
A diferencia de las interfaces List y Set en Kotlin que extienden la interfaz Collection, la interfaz Map no extiende nada. Algunas de las propiedades y funciones disponibles en esta interfaz se muestran a [g1] continuaci√≥n. Observa como solo se permite hacer consultas, al definir una colecci√≥n inmutable.
```java
//size: tama√±o de la colecci√≥n.

isEmpty(): //indica si el mapa est√° vac√≠o.
containsKey(key: K): //indica si el mapa contiene una clave.
containsValue(value: V): // indica si el mapa contiene un valor.
get(key: K): //valor asociado a la llave dada o null si no se encuentra.
keys: //devuelve un Set inmutable con todas las claves en el mapa.
values: Collection //inmutable de todos los valores en el mapa.
mapOf() //crea un mapa inmutable compuesto por una lista de pares, donde el primer valor es la clave, y el segundo es el valor. Devuelve un objeto de tipo Map.

val prefijos: Map<Int, String> = mapOf(34 to "Espa√±a", 1 to "USA", 233 to "Ghana")
for ((key, value) in prefijos) {
    println("$key es el c√≥digo telef√≥nico de $value")
}

//Podemos obtener el valor de una clave usando la funci√≥n get(). Tambi√©n podemos usar los corchetes como un atajo para get().

print(prefijos.get(34)) // Espa√±a
print(prefijos[34])     // Espa√±a 

//La interfaz MutableMap no extiende la interfaz MutableCollection; su √∫nico padre es la interfaz Map. Este anula las propiedades keys, entries y values de la interfaz padre para poder redefinirlas. Adem√°s, incluye algunas funciones extra como:

put(key: K, value: V) //inserta el par clave-valor en el mapa. Devolver√° el valor previo enlazado con la clave o null si la clave no exist√≠a.
remove(key: K) //borra la clave y su valor enlazado.
putAll(from: Map<out K, V>) //agrega nuevos pares clave-valor desde otro mapa. Si una clave ya existente ser√° actualizada con el nuevo valor.
clear() //elimina todos los elementos del mapa.
mutableMapOf() //permite crear un mapa mutable sin indicar la implementaci√≥n:

val monedas: MutableMap<String, String> = mutableMapOf("euro" to "Espa√±a", "dolar" to "EEUU", "libra" to "UK")

println("Paises ${ monedas.values}") 
println("Monedas ${ monedas.keys}") 
monedas.put("cedi", "Ghana")
monedas.remove("dolar")  

```
Para indicar implementaciones espec√≠ficas dispones de: hashMapOf() para crear un mapa de tipo LinkedHashMap., donde puedes consultar el orden en que los elementos fueron insertados, y sortedMapOf() para SortedMap, en el cual todas las entradas se almacenan en un orden de clave ascendente.



### Sets

Set Es similar a una lista, pero sin elementos repetidos

```java
fun main(args: Array<String>) {

    //Conjunto inmutable
    val vocalesRepidas = setOf("a", "e", "i", "o", "u", "a", "e", "i", "o", "u")
    println(vocalesRepidas)

    //Conjunto mutable
    val numerosFavoritos = mutableSetOf(1, 2, 3, 4)
    println(numerosFavoritos)
    numerosFavoritos.add(5)
    numerosFavoritos.add(5)
    println(numerosFavoritos)
    // Se elimina el elemento dependiendo del valor
    numerosFavoritos.remove(1)
    println(numerosFavoritos)

    val valorDelSet = numerosFavoritos.firstOrNull{ num -> num > 2}
    println(valorDelSet)
}
```

### ¬øQu√© son las funciones?

Las funciones se declaran usando la palabra clave fun, seguida del nombre del m√©todo, los par√©ntesis donde declararemos los valores de entrada y unas llaves que limitan la funci√≥n.

```java
fun main(args: Array<String>) {
    showMyName()
    showMyLastName()
    showMyAge()
}
fun showMyName(){
    println("Me llamo Aris")
}
fun showMyLastName(){
    println("Mi Apellido es Guimer√°")
}
fun showMyAge(){
    println("Tengo 24 a√±os")
}
```
Si os fij√°is en el c√≥digo anterior, tenemos 4 m√©todos. 3 de ellos est√°n destinados para una sola funci√≥n (mostrar nombre, edad y apellidos) pero no se ejecutar√°n a no ser que sean llamados. Por ello el cuarto m√©todo que es el que se ejecutar el c√≥digo, los llamar√° en el orden que le pongamos. D√°ndonos un resultado as√≠.

Funciones con par√°metros de entrada
Ahora vamos a ver las funciones con par√°metros de entrada, que son iguales, pero al llamarlas habr√° que mandarle las variables que necesite.

```java
fun main(args: Array<String>) {
    showMyInformation("Aris", "Guimer√°", 24)
}
fun showMyInformation(name: String, lastName: String, age: Int){
    println("Me llamo $name $lastName y tengo $age a√±os.")
}
```
Como se puede observar, tiene tres par√°metros de entrada, la forma de declararlos es muy f√°cil el nombre de la variable, seguida de dos puntos y el tipo de variable, aqu√≠ si es obligatorio definir el tipo.

Obviamente al llamar al m√©todo podemos pasarle variables recuperadas de otros m√©todos y dem√°s.

Funciones con par√°metros de salida
Nos queda por ver como una funci√≥n puede devolver un resultado o lo que haga nuestro m√©todo. La √∫nica limitaci√≥n es que solo se puede devolver un par√°metro, aunque para eso tenemos los m√©todos (ya lo veremos m√°s tarde).

```java
fun main(args: Array<String>) {
    var result = add(5, 10)
    println(result)
}
fun add(firsNumber: Int, secondNumber: Int) : Int{
    return firsNumber + secondNumber
}

```

Como el ejemplo anterior a√±adimos los par√°metros de entrada pero esta vez, al cerrar los par√©ntesis pondremos el tipo de variable que debe devolver nuestra funci√≥n. Luego la funci√≥n har√° todo lo que tenga que hacer y cuando tenga el resultado, lo devolveremos con la palabra clave return.

Si el m√©todo es muy f√°cil, podemos evitar las llaves y simplificar la funci√≥n un poco m√°s.

```java
fun add(firsNumber: Int, secondNumber: Int) : Int = firsNumber + secondNumber
```

### Funciones de extensi√≥n en Kotlin

Las funciones de extensi√≥n (o extension functions en ingl√©s) son funciones que, como su propio nombre indica, nos ayudan a extender la funcionalidad de clases sin necesidad de tocar su c√≥digo. Ahora vamos a ver c√≥mo se definen estas funciones, y algunos ejemplos que a m√≠ personalmente me resultan muy √∫tiles.

¬øC√≥mo se define una funci√≥n de extensi√≥n?
Tan solo hay que escribir una funci√≥n como lo har√≠as normalmente, y ponerle delante el nombre de la clase separado por un punto.

Ejemplo muy sencillo: queremos hacer que una vista tenga la funci√≥n visible(), que la hace visible. Escribir√≠amos algo como esto:

```java
fun View.visible() {
    this.visibility = View.VISIBLE
}
//El this  lo he puesto para que veas que podemos usar las funciones y propiedades de esa clase como si estuvi√©ramos dentro de  la propia clase, pero lo puedes omitir:

fun View.visible() {
    visibility = View.VISIBLE
}

```
Algunos ejemplos interesantes
Hay un par de ejemplos que me gusta poner, porque resumen muy bien la potencialidad de esto.

El primero es cuando est√°s inflando una vista dentro de un adapter. Normalmente utilizar√≠as algo as√≠:

```java
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    val v = LayoutInflater.from(parent.context).inflate(R.layout.view_item, parent, false)
    return ViewHolder(v)
}
```
La l√≠nea que infla la vista y usa el parent es demasiado compleja, y el 99% de las veces suele ser igual en cualquier adapter. ¬øPor qu√© no hacer que los ViewGroup  puedan inflar vistas?

```java
fun ViewGroup.inflate(layoutRes: Int): View {
    return LayoutInflater.from(context).inflate(layoutRes, this, false)
}

//Ahora ya puedes utilizarlo en el c√≥digo de arriba:

override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
    val v = parent.inflate(R.layout.view_item)
    return ViewHolder(v)
}
```
Un ejemplo muy parecido se puede hacer con las im√°genes. Si utilizas por ejemplo la librer√≠a de Picasso, necesitas andar haciendo el t√≠pico ritual:

Picasso.with(imageView.context).load(url).into(imageView)

¬øQu√© te parecer√≠a poder decirle a ImageView que cargue una url directamente?

```java
fun ImageView.loadUrl(url: String) {
    Picasso.with(context).load(url).into(this)
}

imageView.loadUrl(url)
```

Propiedades de extensi√≥n

Igual que puedes hacer funciones de extensi√≥n, lo mismo puedes hacer con properties. Lo √∫nico que no podr√°n guardar un estado propio, sino valerse de las funciones ya existentes para modificar el estado:

```java
val ViewGroup.children: List get() = (0..childCount -1).map { getChildAt(it) }
//  Esta property recupera los hijos de un ViewGroup
// Ahora podr√≠as iterar sobre ellos directamente:
parent.children.forEach { it.visible() }
```

Nota: it es una palabra reservada que se utiliza para acceder al valor de entrada de la funci√≥n, cuando solo hay uno. Como ya hemos visto en otros art√≠culos, se pueden nombrar esos valores de entrada, y asignar m√°s cuando hay m√°s de uno.

Conclusi√≥n
Con las funciones y las propiedades de extensi√≥n puedes extender cualquier librer√≠a a la que no tengas acceso y luego utilizar esas funciones y propiedades como si fueran propias de la clase. Lo √∫nico que ver√°s es un import extra en el archivo en el que se use.

Si de verdad vas en serio con Kotlin y, como yo, piensas que es el lenguaje del futuro en Android, te recomiendo que le eches un vistazo al training gratuito, donde te contar√© todo lo que necesitas para aprender a crear tus Apps Android en Kotlin desde cero.

### Par√°metros por defecto

Una de las caracter√≠sticas de Kotlin es la posibilidad de trabajar con funciones con par√°metros con valores por defecto. Tomemos como ejemplo la funci√≥n sum que tiene dos par√°metros y le agregamos un par√°metro m√°s:
```java
fun sum(x:Int, y:Int, z:Int): Int{
   return x + y + z
}

//Se podr√≠a asignar un valor a una de las variables:

fun sum(x:Int, y:Int, z:Int = 0): Int{
   return x + y + z
}

//Luego la funci√≥n sum, podr√≠a llamarse de las siguientes maneras:

sum(3, 2, 1)
sum(2, 4)

```
En ambos casos funciona en forma adecuada. Esto tiene una ventaja pues permite crear funciones con par√°metros por defecto, con lo cual evita realizar sobre carga de funciones. En lenguajes como Java no hay par√°metros por defecto, con lo cual muchas veces se tiene que sobre cargar los m√©todos.

Par√°metros con nombres
Que sucede si queremos imprimir determinados par√°metros que no sean contiguos, por ejemplo, el primero y el tercero.

```java
//Generamos una nueva funci√≥n:

fun printDetails(name:String,email:String = "", phone:String){
 println("name: $name - email: $email - phone: $phone")
}

//Si hacemos email con un valor por defecto:

printDetails("Juan", "123 123")
```
Esta funci√≥n nos genera erro, pues el tercer valor phone, no tiene asignado un valor por defecto y es requerido. Por otro lado, por la forma de la variable, el valor indicado corresponde a phone, m√°s el m√©todo no sabe como distinguir que es el tercer par√°metro. Esto se soluciona utilizando el valor de los par√°metros:

```java
printDetails("Juan", phone="123 123")

//Al tener el nombre de los par√°metros, se pueden ingresar los par√°metros en un orden indistinto:

printDetails(name="Juan", phone = "123 123")
printDetails(phone = "123 123", name="Juan" )

```
Esto es util cuando tengo funciones con m√∫ltiples par√°metros. Usar el nombre de los par√°metros permite ser m√°s expresivo con nuestro c√≥digo.

No es recomendable tener funciones con cinto o seis par√°metros, para esto es recomendable tener un objeto que agrupe este conjunto de par√°metros, pero en caso de que tengamos este tipo de funciones. El uso de los nombres es muy √∫til.
