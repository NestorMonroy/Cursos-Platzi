Curso de Introducción al Pensamiento Computacional con Python

La primer computadora fue griega, calculaba las posiciones del sol, la luna y del zodiaco. Si sabes la posición del sol sabes cuando preparar tus campos, tus batallas.

El telar de Jakart fue el siguiente paso, los ponch card representaban la información. Por primera vez nos dimos cuenta que podemos separar el cálculo de los procedimientos.

Babage ideo una máquina que generara cálculos, mediante engranajes.Podíamos separar las instrucciones del cálculo.

Alan Turing y Alonso Church, entendieron que todos los algoritmos de la humanidad eran en principio el mismo, la misma secuencia de soluciones matemáticas. A partir de aquí se dió la carrera de construir la primera computadora electrónica. ENIAC (Electronic Numerical Integrator and computer) primera computadora digital, creada en 1943.Era posible recalcular, pero la conexiones en esta máquina tomaba semanas y usaba sistemas decimales.

Usamos el sistema binario porque da ventajas en términos de electrónica.

Von Neuman se da cuenta que es posible dentro de los componentes electrónicos, almacenar los procediemitnos y resultados. Así nace la primer computadora de nombre EDVAC (Electronic Discrete Variable Automatic Computer), era una máquina basada en el sitema binario y fue considerada un éxito en el mundo de la informática. Nace la los cimientos de la computación como la conocemos.

De allí existió la tendencia de la reducción de transistores, para disminuir el tamaño de la máquina, el waffer de silicon es el sitio donde ocurren los cálculos en la computadora en la actualidad, es una gran arquitectura minuaturizada, y solo fue nuestro poder de manipular la luz lo que nos ha permitido llegar a esto, al nivel de microns se ven las estructuras de los chips y solo los microscopios de electrones son aquellos instrumentos que permiten ver a estas escalas.

Existen probelmas que todavía no podemos resolver de manera computacional. Richar Feyman, profesor de física, dió las bases del cómputo cuantico.

No es posible simular computos cuanticos sin sistemas cuanticos.

Hoy en día existen proyectos para poder materializar las especulaciones matemáticas. En 2019 IBM lanzó el “Q System One” fue la primer computadora introducida para uso comercial, el 20 Septiembre, Google afirmó haber alcnazado la “supremacía cuantica”. Los resultados de estos avances están por sentirse.

Conocimiento delcarativo: Relaciones existentes entre diversas variables
Conocimiento imperativo: Como podemos llegar a un resultado.

Algoroitmo :
Es una lista finita de instrucciones que describen un cómputo, que cuando se ejecuta con ciertas entradas ejecuta pasos intermedios para llegar a un resultado.

Las ideas de los algoritmos dieron la idea de lenguajes progamación.

Con Ada Lovelace contemporánea de Babbage, con las bases teóricas del motor analítica.

Ella escribió lo que sería la serie o número de Bernulli. La serie o números de Bernulli : Es una secuencie de números racionales que ocurren frecuentemente en la teoría de números, Ada, escribió para el motor analítico un algoritmo generado para esta secuencia y por ello, se conoce a los números de Bernoulli como el primer “programa de computación”.

Las computadoras entienden una secuencia finita de 0 - 1, representan qué instrucción voy a dar y donde.


Para desarrollar Grace Hopper fue la primera en entender que puede escribir una serie de instrucciones que leen otro progama que puede entender la computadora. Esta idea fue la fundó los lenguajes de programación.

Lenguaje de programacion para los humanos 

El profesor Dennis Ritchie inventó el lenguaje C y cocreador, junto con Ken Thompson, del sistema operativo Unix. La sintáxis en que está escrito es muy eficiente, y su estructura está muy cerca al lenguaje máquina, es casi la base de todos los lenguajes de programación. Posterior tenemos a Guido Van Rossum, los volvió comprensibles, los acercó al lenguaje natural.
Eliminó casi todos los símbolos para poder volverlo más legible. Por eso Python es tan cercano al aprendizaje del lenguaje natural y es usado como lenguaje de cimientos.

Los lenguajes de programación modernos se les llama Turing completness en los que podemos implementar cualquier algoritmo.

Todos los lenguajes de programación poseen:

Sintaxis :
Define la secuencia de símbolos que está bien formada. La morfolgía de la palabra que usamos.

Semánica estática :
Define qué enunciados con sintaxis correcta tiene significado. Habla de cuales combinación representan una idea.

Semánica :
Define el significado. En los lenguajes de programación solo hay un significado. Cual de todos los significados puede ser el correcto. No existe ambiguedad, en programación no existe el contexto.


¿Qué es un lenguaje de programación?

Es un lenguaje formal que, mediante una serie de instrucciones, le permite a un programador escribir un conjunto de órdenes, acciones consecutivas, datos y algoritmos para, de esa forma, crear programas que controlen el comportamiento físico y lógico de una máquina.

¿Qué tipos de lenguaje de programación existen?
El lenguaje de programación es la base para construir todas las aplicaciones digitales que se utilizan en el día a día y se clasifican en dos tipos principales: lenguaje de bajo nivel y de alto nivel.

Lenguaje de programación de bajo nivel
Son lenguajes totalmente orientados a la máquina.
Este lenguaje sirve de interfaz y crea un vínculo inseparable entre el hardware y el software.

Lenguaje de programación de alto nivel
Tienen como objetivo facilitar el trabajo del programador, ya que utilizan unas instrucciones más fáciles de entender.

Lenguaje específico de dominio
En desarrollo de software e ingeniería de dominio, un lenguaje específico de dominio, o “lenguaje específico del dominio”, (en inglés domain-specific language, DSL) es un lenguaje de programación o especificación dedicado a resolver un problema en particular, representar un problema específico y proveer una técnica para solucionar una situación particular. El concepto no es nuevo pero se ha vuelto más popular debido al aumento del uso de modelaje específico del dominio.1​

Lenguaje de propósito general
Se llama lenguaje de propósito general al lenguaje de programación cuyos procedimientos, instrucciones y estructuras de datos están diseñados para resolver todo tipo de problemas.

Lenguaje de interpretados y compilados
La principal diferencia entre un lenguaje compilado y uno interpretado es que el lenguaje compilado requiere un paso adicional antes de ser ejecutado, la compilación, que convierte el código que escribes a lenguaje de máquina. Un lenguaje interpretado, por otro lado, es convertido a lenguaje de máquina a medida que es ejecutado.

Ejemplos de lenguajes compilados incluyen C, C++, Java, Go y Rust, entre muchos otros. Ejemplos de lenguajes interpretados incluyen Ruby, Python y JavaScript, entre muchos otros. A todos estos lenguajes se les conoce como lenguajes de alto nivel.

¿Que es un objeto?
Concepto, abstracción o cosa con límites bien definidos y con significado para el problema que se está manejando

Las variables son simplemente nombres asociados a espacios en memoria.
Siempre y cuando las variable son se llamen como las palabras reservadas y que respeten la forma en que cada lenguaje de programación posee sus estándares
El nombre de la variable no cambia, cambia es el apuntador en memoria.

El garbage collector es el que permite liberar el espacio de memoria para que se puedan hacer reasignaciones.

Garbage collector:En ciencias de la computación el garbage collector umecanismo automático de gestión de memoria, trata de recoger la memorique ocupaban lso objetos en memoria que ya no son usados en el programa.

Cadenas
Las cadenas son secuencias de caracteres.
•	Los objetos de tipo str pueden representarse con “ ” o ‘ ’.
•	El operador + tiene diferente significado según el tipo de dato (overloaded). Con cadenas significa concatenación.
•	El operador * es el operador de repetición con cadenas.
•	Las cadenas son inmutables.
len(longitud)
indexing()
slicing

Entradas
•	Python tiene la función input para recibir datos del usuario del programa.
•	Input siempre regresa cadenas, por lo que si queremos utilizar otro tipo, tenemos que hacer type casting

Programas ramificados
Para que nuestros programas realicen trabajos interesantes estos deben ser capaces de tomar decisiones, test o pruebas, es desde este concepto donde salen las ramificaciones. Dentro de los test que podemos realizar son los operadores de comparación y estos nos devolveras si la comparación es verdadera (True) o falsa (False).
Igual (==): Lo utilizaremos para comparar 2 objetos.
Distinto (!=): Verificamos que los objetos sean distintos.
Mayor que (>): Igual que en algebra, comparamos si el primer termino es mayor que el segundo.
Menor que (<): Verificamos que el primer termino sea menor que el segundo.
Mayor igual que (>=): Verificamos que el primer termino sea mayor igual al segundo.
Menor igual que (<=): Verificamos que el primer termino sea menor igual al segundo.

Ademas de los operadores de comparación también tenemos los operadores lógicos, estos son 3 (and, or, not).


Los bucles, en diversos lenguajes de programación pueden ser definidos o indefinidos. Los bucles definidos preestablecen las condiciones de la iteración por adelantado. 

Por su parte, los bucles indefinidos establecen la condición en la que una iteración terminará. En este último tipo de bucles existe el riesgo de que el bucle se vuelva infinito (cuando la condición de suspensión nunca se cumple).

Los bucles definidos se implementan en Python a través del keyword for. Por su parte, los bucles indefinidos se implementan con el keyword while.

El bucle for en Python

debemos entender <iterable> como una colección de objetos; y la <variable> como el elemento específico que se está exponiendo mediante el bucle en cada iteración

Iterables

En Python, un iterable es un objeto que se puede utilizar en un bucle definido. Si un objeto es iterable significa que se puede pasar como argumento a la función iter. El iterable que se pasa como parámetro a la función iter regresa un iterator.

```py
>>> iter('cadena') # cadena
>>> iter(['a', 'b', 'c']) # lista
>>> iter(('a', 'b', 'c')) # tupla
>>> iter({'a', 'b', 'c'}) # conjunto
>>> iter({'a': 1, 'b': 2, 'c': 3}) # diccionario

```

Todas las llamadas anteriores regresan un objeto de tipo iterator.

Un iterator es un objeto que regresa sucesivamente los valores asociados con el iterable.

```py
>>> frutas = ['manzana', 'pera', 'mango']
>>> iterador = iter(frutas)
>>> next(iterador)
manzana
>>> next(iterador)
pera
>>> next(iterador)
mango
```

Bucles for con diccionarios

Para iterar a lo largo de un diccionario tenemos varias opciones:

Ejecutar el bucle for directamente en el diccionario, lo cual nos permite iterar a lo largo de las llaves del diccionario.

Ejecutar el bucle for en la llamada keys del diccionario, lo cual nos permite iterar a lo largo de las llaves del diccionario.

Ejecutar el bucle for en la llamada values del diccionario, lo cual nos permite iterar a lo largo de los valores del diccionario.

Ejecutar el bucle for en la llamada items del diccionario, lo cual nos permite iterar en una tupla de las llaves y los valores del diccionario.

```py
estudiantes = {
    'mexico': 10,
    'colombia': 15,
    'puerto_rico': 4,
}

for pais in estudiantes:
    ...

for pais in estudiantes.keys():
    ...

for numero_de_estudiantes in estudiantes.values():
    ...

for pais, numero_de_estudiantes in estudiantes.items():
    ...
```

Podemos modificar el comportamiento de un bucle for mediante los keywords
break y continue.

break termina el bucle y permite continuar con el resto del flujo de nuestro
programa.

continue termina la iteración en curso y continua con el siguiente ciclo de
iteración.

Python tenemos 53 bits de precisión para números flotantes

Abstracción: no necesitas saber cómo algo funciona internamente para poderlo utilizar.

Descomposición:
Dividir el código en componentes que colaboran con un fín en común.


El scope o alcance básicamente define las variables, funciones demás a los que una parte del código tiene acceso. El scope va cambiando conforme la ejecución avanza en el programa, por ejemplo, al invocarse una función, el scope actual queda guardado en memoria y se crear un nuevo scope para la función.
Se puede visualizar como esas muñecas rusas que se pueden meter una dentro de otra, de la misma forma hay scopes dentro de un scope dentro de otro scope y así sucesivamente.

El docstring o la documentación está dividido en tres partes importantes que son las siguientes:
Primero se da una descripción clara y concisa de la función y su funcionamiento
En medio se agrega la descripción de los diferentes parámetros, su tipo, su nombre y que es lo que se espera de esos parámetros
Por ultimo se agrega que es lo que devuelve nuestra función

limite de recursividad en python
1000

```py
>>> import sys
>>> print(sys.getrecursionlimit())
1000

```

Las funciones en Python son “ciudadanos de primera clase”.

Esto, en sentido amplio, significa que en Python las funciones:

Tienen un tipo
Se pueden pasar como argumentos de otras funciones
Se pueden utilizar en expresiones
Se pueden incluir en varias estructuras de datos (como listas, tuplas, diccionarios, etc.)


Argumentos de otras funciones

```py
def multiplicar_por_dos(n):
    return n * 2

def sumar_dos(n):
    return n + 2

def aplicar_operacion(f, numeros):
    resultados = []
    for numero in numeros:
        resultado = f(numero)
        resultados.append(resultado)

>>> nums = [1, 2, 3]
>>> aplicar_operacion(multiplicar_por_dos, nums)
[2, 4, 6]

>>> aplicar_operacion(sumar_dos, nums)
[3, 4, 5]

```

Funciones en expresiones

Una forma de definir una función en una expresión es utilizando el keyword lambda. lambda tiene la siguiente sintaxis: lambda <vars>: <expresion>.


```py
sumar = lambda x, y: x + y

>>> sumar(2, 3)
5

```

Funciones en estructuras de datos

Las funciones también se pueden incluir en diversas estructuras que las permiten almacenar. Por ejemplo, una lista puede guardar diversas funciones a aplicar o un diccionario las puede almacenar como valores.


```py
def aplicar_operaciones(num):
    operaciones = [abs, float]

    resultado = []
    for operacion in operaciones:
        resultado.append(operacion(num))

    return resultado

>>> aplicar_operaciones(-2)
[2, -2.0]

```

Tuplas

Una tupla consiste en objetos inmutables. (Objetos que no pueden cambiar después de la creación)
Una tupla tiene poca memoria.
Una tupla se almacena en un solo bloque de memoria.
Crear una tupla es más rápido que crear una lista.
Un elemento en una tupla no se puede quitar ni reemplazar.

```py
tuple_name = ('first_value', 2, 'u_can_add_ints')

```
Listas

Una lista consta de objetos mutables. (Objetos que se pueden cambiar después de la creación)
La lista tiene una gran memoria.
La lista se almacena en dos bloques de memoria (uno es de tamaño fijo y el otro es de tamaño variable para almacenar datos)
Crear una lista es más lento porque se necesita acceder a dos bloques de memoria.
Un elemento en una lista se puede eliminar o reemplazar.

Rangos

son inmutables
Representan una secuencia de enteros

```py
#range(comienzo, fin , pasos)

my_range = range(1,5)
for i in my_range
    print(i)

1
2
3
4

```
listas: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists

Los nuevos que encontré además de los de la clase:

lista.extend(iterable) #extiende la lista con valores dentro de un iterable como un range()
lista.insert(i, ‘valor’) #Agrega un valor en la posición i y recorre todos los demás. No borra nada.
lista.pop(i) #Elimina valor en la posición i de la lista.
lista.remove(‘valor’) #Elimina el primer elemento con ese valor.
lista.clear() #Borra elementos en la lista.
lista.index(‘valor’) #Retorna posición del primer elemento con el valor.
lista.index(‘valor’, start, end) #Retorna posición del elemento con el valor dentro de los elementos desde posición start hasta posición end)
lista.count(‘valor’) #Cuenta cuántas veces esta ese valor en la lista.
lista.sort() #Ordena los elementos de mayor a menor.
lista.sort(reverse = True) #Ordena los elementos de menor a mayor.
lista.reverse() #Invierte los elementos
lista.copy() #Genera una copia de la lista. También útil para clonar listas.

Pruebas de caja negra

Las pruebas de caja negra se basan en la especificación de la función o el programa, aquí debemos probas sus inputs y validar los outputs. Se llama caja negra por que no necesitamos saber necesariamente los procesos internos del programa, solo contrastar sus resultados.
Estos tipos de pruebas son muy importantes para 2 tipos de test:

Unit testing: se realizan pruebas a cada uno de los módulos para determinar su correcto funcionamiento.

Integration testing: es cuando vemos que todos los módulos funcionan entre sí.

Es una buena práctica realizar los test antes de crear tus lineas de código, esto es por que cualquier cambio que se realice a futuro los test estaran incorporados para determinar si los cambios cumplen lo esperado.

En Python existe la posibilidad de realizar test gracias a la libreria unittest. Puede ser que el siguiente código no lo entiendas en su totalidad, pero en una próxima guía detallare mas el tema de clases en programación. Por ahora te mostrare como se realizan estos test.

Pruebas de caja de cristal

Se basan en el flujo del programa, por lo que se asume que conocemos el funcionamiento del programa, por lo que podemos probar todos los caminos posibles de una función. Esto significa que vamos a probar las ramificaciones, bucles for y while, recursiónes, etc.

Este tipo de pruebas son muy buenas cuando debemos realizar:

Regression testing o mocks: descubrimos un bug cuando corremos el programa, por lo que vamos a buscar el bug gracias a que conocemos como esta estructurado el código.

Debugging

Los bugs son un problema que les sucede a todos, sin embargo si realizamos test a nuestro programa probablemente tendremos menos bugs, pero esto no es suficiente.

Existen unas reglas generales que nos ayudaran:

No te molestes con el debugger. Aprende a utilizar el print statement.
Estudia los datos disponibles.
Utiliza los datos para crear hipótesis y experimentos. Método científico.
Ten una mente abierta. Si entendieras el programa, probablemente no habría bugs.
Lleva un registro de lo que has tratado, preferentemente en la forma de tests.

Debuguear es un proceso de búsqueda de los bugs, por lo que al diseñar nuestros experimentos debemos acotar el espacio de búsqueda en cada prueba. Una forma ágil de debugear es utilizando una búsqueda binaria con print statements, esto significa que ejecutamos la mitad del código, si no falla entonces sabemos que el problema esta en la otra mitad, y en cada área que vamos acortando lo dividimos por mitades, de esta forma hallaremos rápidamente nuestro bug.

Existe un listado de errores comunes de los cuales también nos podemos apoyar:

Encuentra a los sospechosos comunes (llamado a una función mal escrita, parámetros en orden incorrecto, etc.)
En lugar de preguntarte por qué un programa no funciona, pregúntate por qué está funcionando de esta manera.
Es posible que el bug no se encuentre donde crees que está.
Explícale el problema a otra persona. De preferencia que no tenga contexto.
Lleva un registro de lo que has tratado, preferentemente en la forma de tests.
Vete a dormir.

Excepciones y afirmaciones

Los manejos de excepciones son muy comunes en la programación, no tienen nada de excepcional. Las excepciones de Python normalmente se relacionan con errores de semántica, también podemos crear nuestras propias excepciones, pero cuando una excepción no se maneja (unhandled exception), el programa termina en error.

Las excepciones se manejan con los keywords: try, except, finally. Se pueden utilizar también para ramificar programas.

No deben manejarse de manera silenciosa (por ejemplo, con print statements). Para crear tu propia excepción utiliza el keyword raise.
